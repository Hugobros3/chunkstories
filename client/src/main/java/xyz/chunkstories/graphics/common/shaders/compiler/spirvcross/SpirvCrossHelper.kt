package xyz.chunkstories.graphics.common.shaders.compiler.spirvcross

import graphics.scenery.spirvcrossj.*
import org.slf4j.LoggerFactory
import xyz.chunkstories.api.graphics.shader.ShaderStage
import xyz.chunkstories.graphics.common.shaders.GLSLGraphicsProgram
import xyz.chunkstories.util.OSHelper
import xyz.chunkstories.util.SupportedOS
import java.io.File
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.util.*

/** The API for that is really nasty and fugly so I'll contain it in this file */
object SpirvCrossHelper {
    val logger = LoggerFactory.getLogger("client.shaders")

    fun initSpirvCross() {
        val nativeLib = when (OSHelper.os) {
            SupportedOS.WINDOWS -> "/spirvcrossj.dll"
            SupportedOS.LINUX -> "/libspirvcrossj.so"
            SupportedOS.OSX -> "/libspirvcrossj.jnilib"
        }

        val libRes = javaClass.getResource(nativeLib)
        val file = libRes.file

        println(libRes)

        val random = Random()

        if (libRes.toString().startsWith("jar:")) {
            println("Extracting libspirvcrossj natives manually...")

            val nativeLibTempDirPath = "./cache/${random.nextInt()}"
            val nativeLibTempDir = File(nativeLibTempDirPath)
            nativeLibTempDir.mkdirs()
            nativeLibTempDir.deleteOnExit()

            val nativeLibDest = File("$nativeLibTempDirPath/$nativeLib")
            val bytes = javaClass.getResourceAsStream(nativeLib).readBytes()
            nativeLibDest.writeBytes(bytes)
            println("Done, written to $nativeLibDest")

            nativeLibDest.deleteOnExit()

            System.load(nativeLibDest.absolutePath)
        }
    }

    internal data class ProgramStage(val code: String, val stage: ShaderStage) {
        lateinit var tShader: TShader

        override fun toString(): String = "stage ${stage.extension}"
    }

    val ShaderStage.spirvStageInt: Int
        get() = when (this) {
            ShaderStage.VERTEX -> EShLanguage.EShLangVertex
            ShaderStage.GEOMETRY -> EShLanguage.EShLangGeometry
            ShaderStage.FRAGMENT -> EShLanguage.EShLangFragment
        }

    val ShaderStage.extension: String
        get() = when (this) {
            ShaderStage.VERTEX -> ".vert"
            ShaderStage.GEOMETRY -> ".geom"
            ShaderStage.FRAGMENT -> ".frag"
        }

    fun generateSpirV(transpiledGLSL: GLSLGraphicsProgram, spirv_13: Boolean): GeneratedSpirV {
        libspirvcrossj.initializeProcess()
        val ressources = libspirvcrossj.getDefaultTBuiltInResource()

        val program = TProgram()

        val stages = transpiledGLSL.sourceCode.map { (stage, code) -> ProgramStage(code, stage) }

        for (stage in stages) {
            stage.tShader = TShader(stage.stage.spirvStageInt)

            stage.tShader.setStrings(arrayOf(stage.code), 1)
            stage.tShader.setAutoMapBindings(true)
            stage.tShader.setAutoMapLocations(true)

            var messages = EShMessages.EShMsgDefault
            messages = messages or EShMessages.EShMsgVulkanRules
            messages = messages or EShMessages.EShMsgSpvRules

            if (spirv_13) {
                stage.tShader.setEnvClient(EShTargetClientVersion.EShTargetVulkan_1_1, 100)
                stage.tShader.setEnvTarget(EShTargetLanguage.EShTargetSpv, EShTargetLanguageVersion.EShTargetSpv_1_3)
            }

            val parse = stage.tShader.parse(ressources, 450, false, messages)
            if (!parse) {
                logger.warn(stage.tShader.infoLog)
                logger.warn(stage.tShader.infoDebugLog)
            }

            program.addShader(stage.tShader)
        }

        val link = program.link(EShMessages.EShMsgDefault)
        val ioMap = program.mapIO()

        if (!link || !ioMap) {
            logger.warn(program.infoLog)
            logger.warn(program.infoDebugLog)

            throw Exception("Failed to link/map autogenerated translated code... this sucks now")
        }

        fun ProgramStage.generateSpirV(): ByteBuffer {
            val intermediate = program.getIntermediate(this.stage.spirvStageInt)
            val intVec = IntVec()
            libspirvcrossj.glslangToSpv(intermediate, intVec)
            logger.debug("${intVec.size()} spirv bytes generated")

            return intVec.byteBuffer()
        }

        libspirvcrossj.finalizeProcess()

        return GeneratedSpirV(transpiledGLSL, stages.associateBy({ it.stage }, { it.generateSpirV() }))
    }

    /** the generated spirv the engine can ingest for that shader program */
    data class GeneratedSpirV(val source: GLSLGraphicsProgram, val stages: Map<ShaderStage, ByteBuffer>)
}

private fun <E> List<List<E>>.merge(): List<E> {
    val list = mutableListOf<E>()
    this.forEach { list.addAll(it) }
    return list
}

private fun IntVec.byteBuffer(): ByteBuffer {
    val size = this.size().toInt()
    val bytes = ByteBuffer.allocateDirect(size * 4)
    bytes.order(ByteOrder.LITTLE_ENDIAN)

    for (i in 0 until size) {
        val wth = this.get(i)
        val wth2 = wth.toInt()
        bytes.putInt(wth2)
    }

    bytes.flip()
    return bytes
}

//TODO move
private fun ByteBuffer.bytes(): ByteArray {
    val bytes2 = ByteArray(this.limit())
    this.get(bytes2)
    return bytes2
}

//TODO move
public fun Int.hex(): String {
    var lol = ""
    var t = this

    for (nibble in 0..31 step 4) {
        val r = t and 0xF
        lol = hexs[r] + lol
        t = t shr 4
    }

    return lol
}

//TODO move
val hexs = "0123456789ABCDEF".toCharArray()
